//! WARNING
//! This code was generated by an AI model.
//! Code may not behave as intended.
//! Please review and test thoroughly.

import { XMLParser } from "fast-xml-parser";


export default function XmlToJson(xmlString) {
    try {
        const parser = new XMLParser({
            ignoreAttributes: false,
            textNodeName: "#text",
            trimValues: true,
            parseTagValue: false,
        });
        const parsed = parser.parse(xmlString);
        return walk(parsed);
    } catch (err) {
        console.error("Failed to parse XML:", err);
    }
}

const walk = (node) => {
    const nodeToValue = (v) => {
        if (v == null) return null;
        if (typeof v === "string") return v.trim();
        if (Array.isArray(v)) return v.map(nodeToValue).filter((x) => x !== null);
        if (typeof v === "object") {
            // if this object is just a text node
            if (Object.keys(v).length === 1 && v["#text"]) return v["#text"].trim();
            const out = {};
            for (const k of Object.keys(v)) {
                if (k === "#text") continue;
                out[k] = nodeToValue(v[k]);
            }
            return out;
        }
        return v;
    };

    function processSection(name, node) {
        if (typeof node === "string") {
            return { type: "section", title: name, content: [node.trim()] };
        }
        if (node == null) {
            return { type: "section", title: name, content: [] };
        }

        const keys = Object.keys(node).filter((k) => k !== "#text");
        const section = { type: "section", title: name };

        // If <content> tag exists, use it as content array
        if (node.content !== undefined) {
            const contentArr = Array.isArray(node.content)
                ? node.content.map(val => (typeof val === "object" && "#text" in val
                    ? parseMaybeNumber(val["#text"])
                    : parseMaybeNumber(val)))
                : [typeof node.content === "object" && "#text" in node.content
                    ? parseMaybeNumber(node.content["#text"])
                    : parseMaybeNumber(node.content)];
            section.content = contentArr.filter(v => v !== undefined && v !== null && v !== "");
        }

        // All other tags become properties (arrays if repeated)
        for (const k of keys) {
            if (k === "content") continue;
            const v = node[k];
            if (Array.isArray(v)) {
                section[k] = v.map(val =>
                    typeof val === "object" && "#text" in val
                        ? parseMaybeNumber(val["#text"])
                        : parseMaybeNumber(val)
                );
            } else if (typeof v === "object" && "#text" in v) {
                section[k] = parseMaybeNumber(v["#text"]);
            } else if (typeof v === "string") {
                section[k] = parseMaybeNumber(v);
            }
        }

        // If no <content> and no other tags, but text exists, use as content
        if (!section.content && node["#text"]) {
            section.content = [node["#text"].trim()];
        }

        return section;
    }

    // Helper to parse numbers if possible
    function parseMaybeNumber(val) {
        if (typeof val !== "string") return val;
        const n = Number(val.trim());
        return isNaN(n) ? val.trim() : n;
    }

    if (!node) return { default: [] };

    const resume = node.resume || node;
    const groupsRaw = Array.isArray(resume.group) ? resume.group : resume.group ? [resume.group] : [];

    const groups = groupsRaw.map((gr) => {
        const content = [];
        for (const key of Object.keys(gr)) {
            if (key === "#text") continue;
            const val = gr[key];
            if (typeof val === "string") {
                content.push({ type: "section", title: key, content: [val.trim()] });
            } else if (Array.isArray(val)) {
                val.forEach((v) => content.push(processSection(key, v)));
            } else {
                content.push(processSection(key, val));
            }
        }
        return { type: "group", content };
    });

    return { default: groups };
}
